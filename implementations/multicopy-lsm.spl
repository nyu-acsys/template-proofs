options "-abspreds -simplearrays -propreads -stratify -module multicopy-lsm"

include "array_util.spl"

datatype OptionTS = someTS(tst: Int) | noneTS

datatype OptionNode = someNode(nd: Node) | noneNode

datatype NodeType = memtableNode | sstableNode

struct Node {
  var nodeType: NodeType;
  var tableK: Array<K>;
  var tableT: Array<Int>;
  var tableLen: Int;
  var next: Node;
}

const B: Int

axiom B > 1


define nodeSpatial(x) {
  acc(x) &*& acc(x.tableK) &*& acc(x.tableT)
  &*& x.tableK.length == x.tableT.length
  &*& x.tableK.length == 2*B  // TODO try without
}

function contents_memtable_aux(tableK: Map<Int, K>, tableT: Map<Int, Int>,
    len: Int, i: Int)
  returns (Cn: Map<K, Int>)
{
  0 <= i ?
    (i < len ?
      contents_memtable_aux(tableK, tableT, len, i-1)[tableK[i] := tableT[i]]
      : contents_memtable_aux(tableK, tableT, len, i-1))
    : { k: K :: 0 }
}

define contents_memtable(tableK, tableT, len) {
  contents_memtable_aux(tableK.map, tableT.map, len, len)
}

lemma contents_memtable_found(n: Node, k: K, i: Int)
  requires nodeSpatial(n)
  requires 0 <= i < n.tableLen && n.tableK[i] == k
  requires forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
  ensures nodeSpatial(n)
  ensures contents_memtable(n.tableK, n.tableT, n.tableLen)[k] == n.tableT[i]
{
  // TODO missing term/inst?
  pure assert contents_memtable_aux(n.tableK.map, n.tableT.map, n.tableLen, i)
    == contents_memtable_aux(n.tableK.map, n.tableT.map, n.tableLen, i-1)[n.tableK[i] := n.tableT[i]];

  var j := i;
  while (j < n.tableLen)
    invariant i <= j <= n.tableLen
    invariant forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
    invariant contents_memtable_aux(n.tableK.map, n.tableT.map, n.tableLen, j)[k]
      == n.tableT[i]
  {
    j := j + 1;

    pure assert j < n.tableLen ==>
      contents_memtable_aux(n.tableK.map, n.tableT.map, n.tableLen, j)
      == contents_memtable_aux(n.tableK.map, n.tableT.map, n.tableLen, j-1)[n.tableK[j] := n.tableT[j]];
  }
}

lemma contents_memtable_add(tableK: Map<Int, K>, tableT: Map<Int, Int>,
    old_tableK: Map<Int, K>, old_tableT: Map<Int, Int>,
    len: Int, k: K, t: Int)
  requires tableK == old_tableK[len-1 := k]
  requires tableT == old_tableT[len-1 := t]
  requires 0 < len //<= tableK.length && tableK.length == tableT.length
  // requires tableK.length == old_tableK.length && tableT.length == old_tableT.length
  ensures contents_memtable_aux(tableK, tableT, len, len)
    == contents_memtable_aux(old_tableK, old_tableT, len-1, len-1)[k := t]
{
  assert contents_memtable_aux(tableK, tableT, len, len)
    == contents_memtable_aux(tableK, tableT, len, len-1);
  assert contents_memtable_aux(tableK, tableT, len, len-1)
    == contents_memtable_aux(tableK, tableT, len, len-2)[k := t];

  if (len-2 < 0) {
    assert contents_memtable_aux(tableK, tableT, len, len-2)
      == contents_memtable_aux(old_tableK, old_tableT, len-1, len-2);
  } else {
    var i := 0;
    while (i < len-2)
      invariant 0 <= i <= len-2
      invariant contents_memtable_aux(tableK, tableT, len, i)
        == contents_memtable_aux(old_tableK, old_tableT, len-1, i);
      invariant tableK == old_tableK[len-1 := k]
      invariant tableT == old_tableT[len-1 := t]
      invariant 0 < len //<= tableK.length && tableK.length == tableT.length
      // invariant tableK.length == old_tableK.length
        // && tableT.length == old_tableT.length
    {
      i := i + 1;
      assert contents_memtable_aux(tableK, tableT, len, i)
        == contents_memtable_aux(tableK, tableT, len, i-1)[tableK[i] := tableT[i]];
      assert contents_memtable_aux(old_tableK, old_tableT, len-1, i)
        == contents_memtable_aux(old_tableK, old_tableT, len-1, i-1)[tableK[i] := tableT[i]];
    }
  }

  assert contents_memtable_aux(tableK, tableT, len, len-2)
    == contents_memtable_aux(old_tableK, old_tableT, len-1, len-2);
  assert contents_memtable_aux(old_tableK, old_tableT, len-1, len-2)
    == contents_memtable_aux(old_tableK, old_tableT, len-1, len-1);
}

define nodePure(r, n, es, Cn) {
  true
  // Node is either memtable or sstable:
  && (n.nodeType == memtableNode
      && n == r
      && Cn == contents_memtable(n.tableK, n.tableT, n.tableLen)
    || n.nodeType == sstableNode
      && n != r
      && sorted_map_seg(n.tableK.map, 0, n.tableLen) == true
      && (forall i: Int :: 0 <= i < n.tableLen ==> Cn[n.tableK[i]] == n.tableT[i])
  )
  && 0 <= n.tableLen <= n.tableK.length
  // No self-loops
  && n.next != n && n.next != r
  // Edgeset to next node is KS if non-null
  && (n.next != null
    ==> (forall k: K :: k in es[n.next]))
  // All other nodes have empty edgeset
  && (forall n1: Node :: n1 != n.next ==> es[n1] == {})
  && es[null] == {}
}

// TODO make n first or last arg
define node(r, n, es, Cn) {
  nodeSpatial(n)
  &*& nodePure(r, n, es, Cn)
}

lemma node_sep_star(r: Node, n: Node, es: Map<Node, Set<K>>, es1: Map<Node, Set<K>>, C: Map<K, Int>, C1: Map<K, Int>)
  requires node(r, n, es, C) &*& node(r, n, es1, C1)
  ensures false
{}

lemma node_es_disjoint(r: Node, n: Node, es: Map<Node, Set<K>>, C: Map<K, Int>)
  requires node(r, n, es, C)
  ensures node(r, n, es, C)
  ensures forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in es[n1] || k !in es[n2]) 
{
  pure assert forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in es[n1] || k !in es[n2]) 
  with {
    if (n1 != n2) {
      pure assert true;
    }
  }
}

lemma node_es_empty(r: Node, n: Node, es: Map<Node, Set<K>>, C: Map<K, Int>)
  requires node(r, n, es, C)
  ensures node(r, n, es, C)
  ensures forall k: K :: (k !in es[r] && k !in es[n])
{}


procedure init()
  returns (r: Node, es: Map<Node, Set<K>>, Cr: Map<K, Int>)
  ensures node(r, r, es, Cr)
{
  r := new Node;
  r.tableK := new Array<K>(2*B);
  r.tableT := new Array<Int>(2*B);
  r.tableLen := 0;
  r.next := null;
  r.nodeType := memtableNode;

  es := { n: Node :: {} };
  Cr := { k: K :: 0 };

  return r, es, Cr;
}

// TODO which ones need to be implicit?
procedure inContents(n: Node, k: K,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (res: OptionTS)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn)
  ensures res != noneTS ==> Cn[k] == res.tst
  // TODO make Cn Map<K, OptionTS> instead of:
  // ensures Cn[k] == res
  // ensures res == noneTS ==> (forall j: Int :: 0 <= j < n.tableLen ==> n.tableK[j] != k)
{
  if (n.nodeType == memtableNode) {
    var i := n.tableLen - 1;
    var flag := false;
    while (i >= 0 && !flag)
      invariant node(r, n, es, Cn)
      invariant -1 <= i < n.tableLen
      invariant flag ==> 0 <= i < n.tableLen && n.tableK[i] == k
      invariant forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
    {
      if (n.tableK[i] == k) {
        flag := true;
      } else {
        i := i - 1;
      }
    }
    if (flag) {
      contents_memtable_found(n, k, i);
      return someTS(n.tableT[i]);
    } else {
      return noneTS;
    }
  } else {
    var b, i := arr_find(n.tableK, n.tableLen, k);
    if (b) {
      return someTS(n.tableT[i]);
    } else {
      return noneTS;
    }
  }
}

procedure addContents(n: Node, k: K, t: Int,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (succ: Bool, implicit ghost Cn1: Map<K, Int>)
  requires node(r, n, es, Cn) &*& n == r
  ensures node(r, n, es, Cn1)
  ensures (succ && Cn1 == Cn[k := t]) || (!succ && Cn1 == Cn)
{
  pure assert n.nodeType == memtableNode;
  pure assert Cn == contents_memtable(n.tableK, n.tableT, n.tableLen);

  if (n.tableLen < n.tableK.length) {
    n.tableK[n.tableLen] := k;
    n.tableT[n.tableLen] := t;
    n.tableLen := n.tableLen + 1;

    contents_memtable_add(
      n.tableK.map, n.tableT.map, old(n.tableK.map), old(n.tableT.map),
      n.tableLen, k, t
    );

    return true;
  } else {
    return false;
  }
}

procedure findNext(n: Node, k: K,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (res: OptionNode)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn)
  ensures res != noneNode ==> k in es[res.nd]
  ensures res == noneNode ==> (forall n2: Node :: k !in es[n2])
{
  if (n.next == null) {  // Leaf node
    return noneNode;
  } else {
    return someNode(n.next);
  }
}

procedure atCapacity(n: Node,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (b: Bool)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn)
{
  if (n.tableLen < n.tableK.length) {
    return false;
  } else {
    return true;
  }
}

define needsNewNode(n) {
  n.next == null
}

procedure chooseNext(n: Node,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (res: OptionNode)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn)
  ensures (res == noneNode && needsNewNode(n)
    || res != noneNode && es[res.nd] != {})
{
  if (n.next != null) {
    return someNode(n.next);
  } else {
    return noneNode;
  }
}

procedure insertNode(n: Node, m: Node,
    ghost r: Node, ghost esn: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (ghost esn1: Map<Node, Set<K>>, ghost esm: Map<Node, Set<K>>, ghost Cm: Map<K, Int>)
  requires node(r, n, esn, Cn) &*& nodeSpatial(m)
  requires needsNewNode(n) &*& m != r
  ensures node(r, n, esn1, Cn) &*& node(r, m, esm, Cm) &*& esn1[m] != {}
{
  n.next := m;
  esn1 := { x: Node :: x == m ? { k: K :: true } : {} };

  m.tableLen := 0;
  m.next := null;
  m.nodeType := sstableNode;
  esm := { x: Node :: {} };
  Cm := { k: K :: 0 };

  return esn1, esm, Cm;
}

// procedure mergeContents(n: Node, m: Node,
//     ghost r: Node, ghost esn: Map<Node, Set<K>>, ghost Cn: Map<K, Int>,
//     ghost esm: Map<Node, Set<K>>, ghost Cm: Map<K, Int>)
//   requires node(r, n, esn, Cn) &*& node(r, m, esm, Cm)
//   requires esn[m] != {}
//   ensures node(r, n, esn, Cn1) &*& node(r, m, esm, Cm1)
//   // ensures TODO
// {
//   if (n == r) {
//     sort(n.tableK, n.tableT, 0, n.tableLen);
//   }
//   var i_n := 0;
//   var i_m := 0;
//   var j_m := 

// }

// We are given n and m, and the aim is to move keys from n to m until m gets full, and result in valid nodes n and m. (Since we're considering a list-like LSM tree, the edgeset is KS.)
// 1. To handle the case where n == r, we first sort & de-duplicate the keys in n. Now it looks like an sstable.
// 2. We use two pointers i_n = i_m = 0 and start a merge, as in merge-sort, but where we overwrite keys in m with keys in n if they are equal. We also start with j_n = 0 and j_m = m.len. If n.keys[i_n] != m.keys[i_m], then we have two cases:
//   - n.keys[i_n] < m.keys[i_m]: we move the key at i_n to j_m and increment j_m. If j_m is already at capacity, then we move i_n to j_n and increment j_n. The idea is that keys new to m are moved to the end of m if possible, and once m is full we move the keys to the beginning of n.
//   - n.keys[i_n] > m.keys[i_m]: we increment i_m.
// 3. If i_n hits the end before i_m does, we are good. If i_m reaches the end first, then we move the remaining keys in n to the beginning of n (using the pointer j_n).
// 4. The keys in [0..j_n] of n are then sorted and n.len is set to j_n. Keys in [0..j_m] are sorted and m.len is set to j_m.

// Sorting and de-duplicating a memtable to get an sstable is slightly tricky:
// We need to use a sorting algorithm that preserves order between identical keys. We also need a sorting algorithm that sorts two arrays based on the ordering given by elements in one of the arrays, I don't think we have something like this in Grasshopper's test suite. After this stable sort, we still need to walk through and remove duplicates. This can be done in 1 pass, but it needs two pointers and might be a little tricky. Or we can use a tombstone value and do it in 2 passes.