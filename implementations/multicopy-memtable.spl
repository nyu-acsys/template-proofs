options "-abspreds -simplearrays -propreads -stratify"

include "array_util.spl"

pure function KS() returns (res: Set<K>)
{
  { k: K :: lt(k, top) }
}

datatype OptionTS = someTS(tst: Int) | noneTS

datatype OptionNode = someNode(nd: Node) | noneNode

struct Node {
  var len: Int;
  var keys: Array<K>;
  var ptrs: Array<Node>;
  ghost var indices: Map<Node, Int>;
  var tableK: Array<K>;
  var tableT: Array<Int>;
  var tableLen: Int;
}

const B: Int

axiom B > 1


// TODO nodeSpatial
define hrepSpatial(x) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs) &*& acc(x.tableK) &*& acc(x.tableT)
  &*& x.keys.length == 2*B &*& x.ptrs.length == 2*B
  &*& x.tableK.length == x.tableT.length
  &*& x.tableK.length == 2*B
}

function map_of_tables_aux(tableK: Map<Int, K>, tableT: Map<Int, Int>,
    len: Int, i: Int)
  returns (Cn: Map<K, Int>)
{
  0 <= i ?
    (i < len ?
      map_of_tables_aux(tableK, tableT, len, i-1)[tableK[i] := tableT[i]]
      : map_of_tables_aux(tableK, tableT, len, i-1))
    : { k: K :: 0 }
}

define map_of_tables(tableK, tableT, len) {
  map_of_tables_aux(tableK.map, tableT.map, len, len)
}

lemma map_of_tables_found(n: Node, k: K, i: Int)
  requires hrepSpatial(n)
  requires 0 <= i < n.tableLen && n.tableK[i] == k
  requires forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
  ensures hrepSpatial(n)
  ensures map_of_tables(n.tableK, n.tableT, n.tableLen)[k] == n.tableT[i]
{
  // TODO missing term/inst?
  pure assert map_of_tables_aux(n.tableK.map, n.tableT.map, n.tableLen, i)
    == map_of_tables_aux(n.tableK.map, n.tableT.map, n.tableLen, i-1)[n.tableK[i] := n.tableT[i]];

  var j := i;
  while (j < n.tableLen)
    invariant i <= j <= n.tableLen
    invariant forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
    invariant map_of_tables_aux(n.tableK.map, n.tableT.map, n.tableLen, j)[k]
      == n.tableT[i]
  {
    j := j + 1;

    pure assert j < n.tableLen ==>
      map_of_tables_aux(n.tableK.map, n.tableT.map, n.tableLen, j)
      == map_of_tables_aux(n.tableK.map, n.tableT.map, n.tableLen, j-1)[n.tableK[j] := n.tableT[j]];
  }
}

lemma map_of_tables_add(tableK: Map<Int, K>, tableT: Map<Int, Int>,
    old_tableK: Map<Int, K>, old_tableT: Map<Int, Int>,
    len: Int, k: K, t: Int)
  requires tableK == old_tableK[len-1 := k]
  requires tableT == old_tableT[len-1 := t]
  requires 0 < len //<= tableK.length && tableK.length == tableT.length
  // requires tableK.length == old_tableK.length && tableT.length == old_tableT.length
  ensures map_of_tables_aux(tableK, tableT, len, len)
    == map_of_tables_aux(old_tableK, old_tableT, len-1, len-1)[k := t]
{
  assert map_of_tables_aux(tableK, tableT, len, len)
    == map_of_tables_aux(tableK, tableT, len, len-1);
  assert map_of_tables_aux(tableK, tableT, len, len-1)
    == map_of_tables_aux(tableK, tableT, len, len-2)[k := t];

  if (len-2 < 0) {
    assert map_of_tables_aux(tableK, tableT, len, len-2)
      == map_of_tables_aux(old_tableK, old_tableT, len-1, len-2);
  } else {
    var i := 0;
    while (i < len-2)
      invariant 0 <= i <= len-2
      invariant map_of_tables_aux(tableK, tableT, len, i)
        == map_of_tables_aux(old_tableK, old_tableT, len-1, i);
      invariant tableK == old_tableK[len-1 := k]
      invariant tableT == old_tableT[len-1 := t]
      invariant 0 < len //<= tableK.length && tableK.length == tableT.length
      // invariant tableK.length == old_tableK.length
        // && tableT.length == old_tableT.length
    {
      i := i + 1;
      assert map_of_tables_aux(tableK, tableT, len, i)
        == map_of_tables_aux(tableK, tableT, len, i-1)[tableK[i] := tableT[i]];
      assert map_of_tables_aux(old_tableK, old_tableT, len-1, i)
        == map_of_tables_aux(old_tableK, old_tableT, len-1, i-1)[tableK[i] := tableT[i]];
    }
  }

  assert map_of_tables_aux(tableK, tableT, len, len-2)
    == map_of_tables_aux(old_tableK, old_tableT, len-1, len-2);
  assert map_of_tables_aux(old_tableK, old_tableT, len-1, len-2)
    == map_of_tables_aux(old_tableK, old_tableT, len-1, len-1);
}

define nodePure(r, n, es, Cn) {
  true
  && 0 <= n.tableLen <= n.tableK.length
  && (n.ptrs[0] == null  // Leaf
      && (forall n1: Node :: es[n1] == {})
    || n.ptrs[0] != null  // Internal
      && (forall i: Int :: 0 <= i <= n.len ==> n != n.ptrs[i])
      && (forall i: Int, j: Int :: 0 <= i < j <= n.len ==> n.ptrs[i] != n.ptrs[j]
        @(noinst i) @(noinst j))
      && (forall i: Int :: 0 <= i <= n.len ==> n.ptrs[i] != null)
      && (forall i: Int, k: K :: 0 <= i <= n.len ==>
        (k in es[n.ptrs[i]]
          && (0 < i ==> le(n.keys[i-1], k)) && (i < n.len ==> lt(k, n.keys[i]))
        || k !in es[n.ptrs[i]]
          && !((i <= 0 || le(n.keys[i-1], k)) && (i >= n.len || lt(k, n.keys[i]))))
        @(matching n.ptrs[i] yields n.keys[i - 1])
        @(matching n.ptrs[i] yields n.keys[i]))
      && (forall n1: Node :: n.indices[n1] == -1 ==> es[n1] == {})
  )
  // Keys are sorted
  && sorted_map_seg(n.keys.map, 0, n.len) == true
  && 0 <= n.len <= n.keys.length
  // Indices of outgoing pointers are stored in n.indices
  && (forall y: Node :: 0 <= n.indices[y] <= n.len
    ==> n.ptrs.map[n.indices[y]] == y)
  && (forall i: Int :: n.ptrs[0] != null && 0 <= i <= n.len
    ==> n.indices[n.ptrs.map[i]] == i @(noinst i))
  && (forall y: Node :: -1 <= n.indices[y] <= n.len)
  && (n.ptrs[0] == null ==> (forall y: Node :: n.indices[y] == -1 @(noinst y)))
  && n.indices[n] == -1
  && n.indices[r] == -1
}

// TODO make n first or last arg
define node(r, n, es, Cn) {
  hrepSpatial(n)
  &*& nodePure(r, n, es, Cn)
  &*& Cn == map_of_tables(n.tableK, n.tableT, n.tableLen)
}

lemma node_sep_star(r: Node, n: Node, es: Map<Node, Set<K>>, es1: Map<Node, Set<K>>, C: Map<K, Int>, C1: Map<K, Int>)
  requires node(r, n, es, C) &*& node(r, n, es1, C1)
  ensures false
{}

lemma node_es_disjoint(r: Node, n: Node, es: Map<Node, Set<K>>, C: Map<K, Int>)
  requires node(r, n, es, C)
  ensures node(r, n, es, C)
  ensures forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in es[n1] || k !in es[n2]) 
{
  pure assert forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in es[n1] || k !in es[n2]) 
  with {
    if (n1 != n2) {
      if (n.indices[n1] > -1) {
        if (n.indices[n2] > -1) {
          pure assert n.ptrs[n.indices[n1]] == n1 && n.ptrs[n.indices[n2]] == n2;
          if (n.indices[n1] == n.indices[n2]) {
            pure assert false;
          } else {
            pure assert (k !in es[n.ptrs[n.indices[n1]]]
              || k !in es[n.ptrs[n.indices[n2]]]);
          }
        }
      }
    }
  }
}

lemma node_es_empty(r: Node, n: Node, es: Map<Node, Set<K>>, C: Map<K, Int>)
  requires node(r, n, es, C)
  ensures node(r, n, es, C)
  ensures forall k: K :: (k !in es[r] && k !in es[n])
{
}

procedure init()
  returns (r: Node, es: Map<Node, Set<K>>, Cr: Map<K, Int>)
  ensures node(r, r, es, Cr)
{
  r := new Node;
  r.keys := new Array<K>(2*B);
  r.ptrs := new Array<Node>(2*B);
  r.indices := { n: Node :: -1 };
  r.tableK := new Array<K>(2*B);
  r.tableT := new Array<Int>(2*B);
  arr_init_node(r.ptrs, 2*B, null);
  r.len := 0;
  r.tableLen := 0;

  es := { n: Node :: {} };
  Cr := { k: K :: 0 };

  return r, es, Cr;
}

// TODO which ones need to be implicit?
procedure inContents(n: Node, k: K,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (res: OptionTS)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn) &*& (res != noneTS ==> Cn[k] == res.tst)
{
  var i := n.tableLen - 1;
  var flag := false;
  while (i >= 0 && !flag)
    invariant node(r, n, es, Cn)
    invariant -1 <= i < n.tableLen
    invariant flag ==> 0 <= i < n.tableLen && n.tableK[i] == k
    invariant forall j: Int :: i < j < n.tableLen ==> n.tableK[j] != k
  {
    if (n.tableK[i] == k) {
      flag := true;
    } else {
      i := i - 1;
    }
  }
  if (flag) {
    map_of_tables_found(n, k, i);
    return someTS(n.tableT[i]);
  } else {
    return noneTS;
  }
}

// TODO add n == r to precondition?
procedure addContents(n: Node, k: K, t: Int,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (succ: Bool, implicit ghost Cn1: Map<K, Int>)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn1)
  ensures (succ && Cn1 == Cn[k := t]) || (!succ && Cn1 == Cn)
{
  pure assert Cn == map_of_tables(n.tableK, n.tableT, n.tableLen);

  if (n.tableLen < n.tableK.length) {
    n.tableK[n.tableLen] := k;
    n.tableT[n.tableLen] := t;
    n.tableLen := n.tableLen + 1;

    map_of_tables_add(
      n.tableK.map, n.tableT.map, old(n.tableK.map), old(n.tableT.map),
      n.tableLen, k, t
    );

    return true;
  } else {
    return false;
  }
}

procedure findNext(n: Node, k: K,
    ghost r: Node, ghost es: Map<Node, Set<K>>, ghost Cn: Map<K, Int>)
  returns (res: OptionNode)
  requires node(r, n, es, Cn)
  ensures node(r, n, es, Cn)
  ensures res != noneNode ==> k in es[res.nd]
  // TODO this times out:
  // ensures exists n1: Node :: res == someNode(n1) ==> k in es[n1]
  ensures res == noneNode ==> (forall n2: Node :: k !in es[n2])
{
  if (n.ptrs[0] == null) {  // Leaf node
    return noneNode;
  }

  var found, i := arr_find(n.keys, n.len, k);

  if (i < n.len && k == n.keys[i]) {  // arr_find finds upper bound, we want lower
    i := i + 1;
  }

  return someNode(n.ptrs[i]);
}