
options "-simplearrays"

include "array_util.spl"

datatype KT = pair(key: K, ts: Int)

/* Array utils for KT */

pure predicate sorted_map_seg_KT(m: Map<Int, KT>, i: Int, j: Int)
{
  forall i1: Int, i2: Int :: i <= i1 < i2 < j ==> lt(m[i1].key, m[i2].key) @(noinst i1) @(noinst i2)
}

define sorted_array_prefix_KT(a, len)
{
  acc(a) &*& 0 <= len <= a.length &*& sorted_map_seg_KT(a.map, 0, len) == true
}

function map_find_KT(m: Map<Int, KT>, i: Int, j: Int, k: K) returns (idx: Int)
  requires i <= j
  requires sorted_map_seg_KT(m, i, j) == true
  ensures i <= idx <= j
  ensures m[idx].key == k || idx == j || lt(k, m[idx].key)
  ensures i < idx ==> lt(m[idx - 1].key, k)
  ensures idx + 1 < j ==> lt(k, m[idx + 1].key)
{
  i < j && lt(m[i].key, k) ? map_find_KT(m, i + 1, j, k) : i
}

// project map segment m[i..j] to set of its elements
function set_of_map_KT(m: Map<Int, KT>, i: Int, j: Int)
  returns (res: Set<K>)
  requires i <= j
{
  i < j ? {m[i].key} ++ set_of_map_KT(m, i + 1, j) : {}
}

lemma extend_right_KT(m: Map<Int, KT>, i: Int, j: Int)
  requires i <= j
  pure ensures set_of_map_KT(m, i, j) ++ {m[j].key} == set_of_map_KT(m, i, j + 1)
{
  if (i < j) {
    extend_right_KT(m, i + 1, j);
  }
}

lemma not_in_sorted_seg_KT(m: Map<Int, KT>, i: Int, j: Int, k: K)
  requires sorted_map_seg_KT(m, i, j)
  ensures i >= j || lt(k, m[i].key) || lt(m[j-1].key, k) ==> k !in set_of_map_KT(m, i, j)
{
  if (i >= j) return;
  
  if (lt(m[j - 1].key, k)) {
    extend_right_KT(m, i, j - 1);
    not_in_sorted_seg_KT(m, i, j - 1, k);
    return;
  }

  if (lt(k, m[i].key)) {
    not_in_sorted_seg_KT(m, i + 1, j, k);    
    return;
  }
  
}


lemma map_find_content_set_KT(m: Map<Int, KT>, i: Int, j: Int, idx: Int, k: K)
  requires i <= j
  requires sorted_map_seg_KT(m, i, j) == true
  requires idx == map_find_KT(m, i, j, k)
  ensures k !in set_of_map_KT(m, i, idx)
  ensures k !in set_of_map_KT(m, idx + 1, j)
{
  // prove k !in set_of_map(a, 0, idx)
  not_in_sorted_seg_KT(m, i, idx, k);
  // prove: k !in set_of_map(a, idx + 1, len)
  not_in_sorted_seg_KT(m, idx + 1, j, k);
}

lemma set_of_map_split_KT(m: Map<Int, KT>, i: Int, j: Int, k: Int)
  requires i <= j <= k
  ensures set_of_map_KT(m, i, k) == set_of_map_KT(m, i, j) ++ set_of_map_KT(m, j, k)
{
  if (j < k) {
    extend_right_KT(m, i, j);
    set_of_map_split_KT(m, i, j + 1, k);
  }
}

lemma map_find_in_set_KT(m: Map<Int, KT>, i: Int, j: Int, k: K)
  requires i <= j
  requires sorted_map_seg_KT(m, i, j) == true
  ensures k in set_of_map_KT(m, i, j) ==> map_find_KT(m, i, j, k) < j && m[map_find_KT(m, i, j, k)].key == k
  ensures k !in set_of_map_KT(m, i, j) ==> map_find_KT(m, i, j, k) == j || lt(k, m[map_find_KT(m, i, j, k)].key)
{
  var idx := map_find_KT(m, i, j, k);
  map_find_content_set_KT(m, i, j, idx, k);
  set_of_map_split_KT(m, i, idx, j);
}


procedure arr_find_KT(a: Array<KT>, len: Int, k: K)
  returns (found: Bool, idx: Int)
  requires sorted_array_prefix_KT(a, len)
  requires 0 <= len <= a.length
  ensures sorted_array_prefix_KT(a, len)
  ensures a.map == old(a.map)
  // what we actually care about
  ensures idx == map_find_KT(a.map, 0, len, k)
  ensures found == (k in set_of_map_KT(a.map, 0, len))
{
  ghost var am := a.map;
  var lo := 0;
  var hi := len;
  
  while (hi != lo)
    invariant sorted_array_prefix_KT(a, len)
    invariant a.map == am
    // what we actually care about
    invariant 0 <= lo <= hi <= len <= a.length
    invariant hi == len || a.map[lo].key == k || lt(k, a.map[hi].key)
    invariant 0 < lo ==> lt(a.map[lo - 1].key, k)
    invariant hi < len - 1 ==> lt(k, a.map[hi + 1].key)
  {
    var mid := (hi + lo) / 2;
    var cmp: Int;
    cmp := compare(k, a[mid].key);
    if (cmp < 0) {
      hi := mid;      // look in first half
    } else if (cmp > 0) {
      lo := mid + 1;    // look in second half
    } else {
      // found it
      hi := mid;
      lo := mid;
    }
  }
  
  idx := lo;
  
  if (idx == len || lt(k, a[lo].key)) {
    found := false;
  } else {
    found := true;
  }

  map_find_in_set_KT(a.map, 0, len, k);
}

/*
function map_shift_KT(m: Map<Int, KT>, src: Int, dst: Int, len: Int)
  returns (res: Map<Int, KT>)
  requires 0 <= len
{
  { i: Int :: i < dst || dst + len <= i ? m[i] : m[src + (i - dst)]
    @(matching res[i] yields m[src + (i - dst)])
    @(matching res[i] yields m[i])
  }
}


procedure arr_shift_KT(a: Array<KT>, src: Int, dst: Int, len: Int)
  requires acc(a)
  requires src < dst
  requires 0 <= src <= src + len <= a.length && 0 <= dst <= dst + len <= a.length
  ensures acc(a)
  ensures a.map == map_shift_KT(old(a.map), src, dst, len)
{
  ghost var m := a.map;

  if (src < dst) {
    var i := len - 1;
    
    while (i >= 0)
      invariant acc(a)
      invariant src < dst
      invariant 0 <= src <= src + len <= a.length
      invariant 0 <= dst <= dst + len <= a.length
      invariant -1 <= i < len
      invariant map_shift_KT(m, src + i + 1, dst + i + 1, len - i - 1) == a.map
    {
      ghost var m1 := a.map;
      var tmp := a[src + i];
      a[dst + i] := tmp;
      pure assert a.map == m1[dst + i := tmp];
      i := i - 1;
    }
  } else if (src > dst) {
    var i := 0;
    while (i < len)
      invariant acc(a)
      invariant src > dst
      invariant 0 <= src <= src + len <= a.length
      invariant 0 <= dst <= dst + len <= a.length
      invariant 0 <= i <= len 
      invariant map_shift_KT(m, src, dst, i) == a.map
    {
      ghost var m1 := a.map;
      var tmp := a[src + i];
      a[dst + i] := a[src + i];
      pure assert a.map == m1[dst + i := tmp];
      i := i + 1;
    }
  }  
}
