options "-abspreds -simplearrays -propreads -stratify -module multicopy-lsm"

include "array_util_lsm.spl"

type V = Int

/* File axiomatization */
type FileT = Array<Pair>;

predicate File(f: FileT) {
    acc(f)
}

procedure createFile(d: Array<Pair>) returns (f: FileT)
    requires acc(d)
    ensures File(f)
    ensures f == d
{
    return d;
}

procedure readFile(f: FileT) returns (res: Array<Pair>)
    requires File(f)
    ensures File(f)
    ensures res == f
{
    return f;
}

/** LSM-like implementation of the multicopy template. */

datatype OptionNode = someNode(nd: Node) | noneNode

/** Definition of a node */

datatype NodeType = memtableNode | sstableNode

struct Node {
  var nodeType: NodeType;
  var table: Array<Pair>;
  var tableLen: Int;
  var next: Node;
  var file: Array<Pair>
}

const B: Int

axiom B > 1

/** {Spec} Definition of heap representation predicate, node */

define nodeSpatial(x) {
  acc(x) &*& acc(x.table) &*& File(x.file)
}

define nodePure(r, n, esn, Cn) {
  true
  // Node is either memtable or sstable:
  && (n.nodeType == memtableNode
      && n == r
      && Cn == contents(n.table.map, n.table.length - n.tableLen, n.table.length)
      && 0 <= n.tableLen <= n.table.length
    || n.nodeType == sstableNode
      && n != r
      && sorted_map_seg(n.file.map, 0, n.tableLen)
      // Cn is given by table
      && Cn == contents(n.file.map, 0, n.tableLen)
      && 0 <= n.tableLen <= n.file.length
  )
  // No self-loops
  && n.next != n && n.next != r
  // Edgeset to next node is KeyS if non-null
  && (n.next != null
    ==> (forall k: K :: k in esn[n.next]))
  // All other nodes have empty edgeset
  && (forall n1: Node :: n1 != n.next ==> esn[n1] == {})
  && esn[null] == {}
}

// TODO make n first or last arg
define node(r, n, esn, Cn) {
  nodeSpatial(n)
  &*& nodePure(r, n, esn, Cn)
}

define needsNewNode(r, n, esn, Cn) {
  n.next == null
}

function dom(C: Map<K, OptionV>) returns (res: Set<K>) {
  { k: K :: C[k] != NoneV ? true : false}
}

function set_of_map(C: Map<K, OptionV>) returns (res: Set<Pair>) {
  { p: Pair :: C[p.key] == SomeV(p.val) ? true : false }
}

function merge(Cn: Map<K, OptionV>, Es: Set<K>, Cm: Map<K, OptionV>)
  returns (res: Map<K, OptionV>)
{
  { k: K :: Cn[k] != NoneV ? Cn[k] : (k in Es ? Cm[k] : NoneV) }
}

/** {Spec} Some lemmas used by the proof of the programs below */

lemma merge_equals_append(Cn: Map<K, OptionV>, Es: Set<K>, Cm: Map<K, OptionV>)
  requires forall k: K :: k in Es
  ensures merge(Cn, Es, Cm) == append(Cn, Cm)
{
  pure assert forall k: K :: merge(Cn, Es, Cm)[k] == append(Cn, Cm)[k] with {
    if (Cn[k] == NoneV) {
      pure assert merge(Cn, Es, Cm)[k] == Cm[k];
    }
  }
}

lemma dom_empty_map()
  ensures dom(empty_map) == {}
{
  pure assert forall k: K :: k !in dom(empty_map) with {
    pure assert empty_map[k] == NoneV;
  }
}

lemma set_of_empty_map()
  ensures set_of_map(empty_map) == {}
{
  pure assert forall p: Pair :: p !in set_of_map(empty_map) with {
    pure assert empty_map[p.key] == NoneV;
  }
}


/** {Spec} Implementation-specific lemmas needed by Iris */

lemma node_sep_star(r: Node, n: Node, esn: Map<Node, Set<K>>, es1: Map<Node, Set<K>>, C: Map<K, OptionV>, C1: Map<K, OptionV>)
  requires node(r, n, esn, C) &*& node(r, n, es1, C1)
  ensures false
{}

lemma node_es_disjoint(r: Node, n: Node, esn: Map<Node, Set<K>>, C: Map<K, OptionV>)
  requires node(r, n, esn, C)
  ensures node(r, n, esn, C)
  ensures forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in esn[n1] || k !in esn[n2]) 
{
  pure assert forall k: K, n1: Node, n2: Node ::
    n1 != n2 ==> (k !in esn[n1] || k !in esn[n2]) 
  with {
    if (n1 != n2) {
      pure assert true;
    }
  }
}

lemma node_es_empty(r: Node, n: Node, esn: Map<Node, Set<K>>, C: Map<K, OptionV>)
  requires node(r, n, esn, C)
  ensures node(r, n, esn, C)
  ensures forall k: K :: (k !in esn[r] && k !in esn[n])
{}

/** Begin programs */

procedure init()
  returns (r: Node, esr: Map<Node, Set<K>>, Cr: Map<K, OptionV>)
  ensures node(r, r, esr, Cr)
{
  r := new Node;
  r.table := new Array<Pair>(2*B);
  r.tableLen := 0;
  r.next := null;
  r.nodeType := memtableNode;

  var arr_file := new Array<Pair>(2*B);
  r.file := createFile(arr_file);

  esr := { n: Node :: {} };
  Cr := empty_map;

  return r, esr, Cr;
}

procedure inContents(n: Node, k: K,
    implicit ghost r: Node, implicit ghost esn: Map<Node, Set<K>>,
    implicit ghost Cn: Map<K, OptionV>)
  returns (res: OptionV)
  requires node(r, n, esn, Cn)
  ensures node(r, n, esn, Cn)
  ensures Cn[k] == res
{
  if (n.nodeType == memtableNode) {
    var start := n.table.length - n.tableLen;
    var i := start;
    var flag := false;
    while (i < n.table.length && !flag)
      invariant start == n.table.length - n.tableLen;
      invariant node(r, n, esn, Cn)
      invariant start <= i <= n.table.length
      invariant flag ==> start <= i < n.table.length && n.table[i].key == k
      invariant contents(n.table.map, start, i)[k] == NoneV
    {
      if (n.table[i].key == k) {
        flag := true;
      } else {
        contents_extend(n.table.map, start, i);
        i := i + 1;
      }
    }
    if (flag) {
      contents_split(n.table.map, start, i + 1, n.table.length);
      contents_extend(n.table.map, start, i);
      return SomeV(n.table[i].val);
    } else {
      return NoneV;
    }
  } else {
    var arr_file := readFile(n.file);

    var v, i := arr_find(arr_file, n.tableLen, k);
    return v;
  }
}

procedure addContents(n: Node, k: K, t: Int,
   ghost r: Node, ghost esn: Map<Node, Set<K>>,
   ghost Cn: Map<K, OptionV>)
  returns (succ: Bool, implicit ghost Cn1: Map<K, OptionV>)
  requires node(r, n, esn, Cn) &*& n == r
  ensures node(r, n, esn, Cn1)
  ensures (succ && Cn1 == Cn[k := SomeV(t)]) || (!succ && Cn1 == Cn)
{
  pure assert n.nodeType == memtableNode;
  var start := n.table.length - n.tableLen;  
  pure assert Cn == contents(n.table.map, start, n.table.length);

  if (n.tableLen < n.table.length) {
    n.table[start - 1] := pair(k,t);

    contents_extensional(n.table.map, old(n.table.map), start, n.table.length);
    
    n.tableLen := n.tableLen + 1;

    return true;
  } else {
    return false;
  }
}

procedure findNext(n: Node, k: K,
    implicit ghost r: Node, implicit ghost esn: Map<Node, Set<K>>,
    implicit ghost Cn: Map<K, OptionV>)
  returns (res: OptionNode)
  requires node(r, n, esn, Cn)
  ensures node(r, n, esn, Cn)
  ensures res != noneNode ==> k in esn[res.nd]
  ensures res == noneNode ==> (forall n1: Node :: k !in esn[n1])
{
  if (n.next == null) {  // Leaf node
    return noneNode;
  } else {
    return someNode(n.next);
  }
}

procedure atCapacity(n: Node,
    implicit ghost r: Node, implicit ghost esn: Map<Node, Set<K>>,
    implicit ghost Cn: Map<K, OptionV>)
  returns (b: Bool)
  requires node(r, n, esn, Cn)
  ensures node(r, n, esn, Cn)
  ensures b == true || b == false
{
  if (n.nodeType == memtableNode) {
    if (n.tableLen < n.table.length) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}

procedure chooseNext(n: Node,
    implicit ghost r: Node, implicit ghost esn: Map<Node, Set<K>>,
    implicit ghost Cn: Map<K, OptionV>)
  returns (res: OptionNode)
  requires node(r, n, esn, Cn)
  ensures node(r, n, esn, Cn)
  ensures (res == noneNode && needsNewNode(r, n, esn, Cn)
    || res != noneNode && esn[res.nd] != {})
{
  if (n.next != null) {
    return someNode(n.next);
  } else {
    return noneNode;
  }
}

procedure insertNode(n: Node, m: Node,
    implicit ghost r: Node, implicit ghost esn: Map<Node, Set<K>>,
    implicit ghost Cn: Map<K, OptionV>)
  returns (ghost esn1: Map<Node, Set<K>>, ghost esm: Map<Node, Set<K>>, ghost Cm: Map<K, OptionV>)
  requires node(r, n, esn, Cn) &*& nodeSpatial(m)
  requires needsNewNode(r, n, esn, Cn) &*& m != r
  ensures node(r, n, esn1, Cn) &*& node(r, m, esm, Cm)
  ensures esn1[m] != {} && esn1 == esn[m := esn1[m]]
  ensures esm == { x: Node :: {} } && Cm == empty_map
{
  pure assert n != m;
  n.next := m;
  esn1 := { x: Node :: x == m ? { k: K :: true } : {} };

  m.tableLen := 0;
  m.next := null;
  m.nodeType := sstableNode;
  esm := { x: Node :: {} };
  Cm := empty_map;

  return esn1, esm, Cm;
}

procedure allocNode() returns (m: Node)
  requires true
  ensures nodeSpatial(m)
{
  m := new Node;
  m.table := new Array<Pair>(2*B);

  var arr_file := new Array<Pair>(2*B);
  m.file := createFile(arr_file);
}  

/*
procedure addSStable(n: Node, k: K, t: Int,
    ghost r: Node, ghost esn: Map<Node, Set<K>>,
    ghost Cn: Map<K, OptionV>)
  returns (succ: Bool, implicit ghost Cn1: Map<K, OptionV>)
  requires node(r, n, esn, Cn) &*& n != r &*& n.tableLen < n.table.length
  ensures node(r, n, esn, Cn1)
  ensures Cn1 == Cn[k := SomeV(t)]
  ensures n.tableLen <= n.tableLen + 1
{
  pure assert n.nodeType == sstableNode;

  var old_len := n.tableLen;

  var idx, new_len := arr_insert(n., pair(k, t), n.tableLen);
  n.tableLen := new_len;
}
*/

procedure mergeContentsHelper(r: Node, n: Node, m: Node,
  ghost esn: Map<Node, Set<K>>,
  ghost Cn: Map<K, OptionV>,
  ghost esm: Map<Node, Set<K>>,
  ghost Cm: Map<K, OptionV>)
  returns (implicit ghost Cm1: Map<K, OptionV>)
  requires node(r, n, esn, Cn) &*& node(r, m, esm, Cm)
  requires esn[m] != {}
  ensures node(r, n, esn, empty_map) &*& node(r, m, esm, append(Cn, Cm))
{
  assume false;
}

procedure mergeContents(r: Node, n: Node, m: Node,
  ghost esn: Map<Node, Set<K>>,
  ghost Cn: Map<K, OptionV>,
  ghost esm: Map<Node, Set<K>>,
  ghost Cm: Map<K, OptionV>)
  returns (implicit ghost Cn1: Map<K, OptionV>, implicit ghost Cm1: Map<K, OptionV>)
  requires node(r, n, esn, Cn) &*& node(r, m, esm, Cm)
  requires esn[m] != {}
  ensures node(r, n, esn, Cn1) &*& node(r, m, esm, Cm1)
  ensures set_of_map(Cn1) subsetof set_of_map(Cn)
  ensures set_of_map(Cm1) subsetof set_of_map(Cn) ++ set_of_map(Cm)
  ensures Disjoint(set_of_map(Cn) ** set_of_map(Cm1), set_of_map(Cn1))
  ensures dom(Cm) subsetof dom(Cm1)
  ensures merge(Cn, esn[m], Cm) == merge(Cn1, esn[m], Cm1)
{
  mergeContentsHelper(r, n, m, esn, Cn, esm, Cm);
  ghost var Cm11 := append(Cn, Cm);
  ghost var Cn11 := empty_map;
  pure assert merge(Cn, esn[m], Cm) == merge(Cn11, esn[m], Cm11) with {
    merge_equals_append(Cn11, esn[m], Cm11);
    merge_equals_append(Cn, esn[m], Cm);
    append_empty_left(Cm11);
  }
  dom_empty_map();
  set_of_empty_map();
  pure assert set_of_map(Cm11) subsetof set_of_map(Cn) ++ set_of_map(Cm);
  pure assert set_of_map(Cn11) subsetof set_of_map(Cn);
  pure assert Disjoint(set_of_map(Cn) ** set_of_map(Cm11), set_of_map(Cn11));
  pure assert dom(Cm) subsetof dom(Cm11);
}